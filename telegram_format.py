import html
import re

_ALLOWED_TAGS = ("b", "i", "u")
_ALLOWED_TAG_RE = re.compile(r"<\s*(/?)\s*(b|i|u)\s*>", re.IGNORECASE)
_CANONICAL_TAG_RE = re.compile(r"</?(b|i|u)>")


def _balance_allowed_tags(text):
    """
    Ensures allowed tags are properly nested so Telegram HTML parsing does not fail.
    """
    if not text:
        return text

    stack = []
    output = []
    cursor = 0

    for match in _CANONICAL_TAG_RE.finditer(text):
        output.append(text[cursor:match.start()])
        token = match.group(0)
        tag = match.group(1)
        is_closing = token.startswith("</")

        if not is_closing:
            output.append(f"<{tag}>")
            stack.append(tag)
        elif tag in stack:
            while stack and stack[-1] != tag:
                output.append(f"</{stack.pop()}>")
            if stack:
                stack.pop()
                output.append(f"</{tag}>")

        cursor = match.end()

    output.append(text[cursor:])
    while stack:
        output.append(f"</{stack.pop()}>")
    return "".join(output)


def sanitize_telegram_html(message):
    """
    Converts common Markdown emphasis into Telegram-safe HTML and strips
    remaining Markdown markers.

    It also escapes unsafe characters and removes unsupported tags so the final
    payload stays valid for Telegram parse_mode=HTML.
    """
    if not message:
        return message

    text = message.replace("\r\n", "\n")

    # Bold+italic (***text*** or ___text___) first.
    text = re.sub(r"\*\*\*(.+?)\*\*\*", r"<b><i>\1</i></b>", text)
    text = re.sub(r"___(.+?)___", r"<b><i>\1</i></b>", text)

    # Bold.
    text = re.sub(r"\*\*(.+?)\*\*", r"<b>\1</b>", text)
    text = re.sub(r"__(.+?)__", r"<b>\1</b>", text)

    # Italic.
    text = re.sub(r"(?<!\\)\*(?!\s)(.+?)(?<!\s)\*", r"<i>\1</i>", text)
    text = re.sub(r"(?<!\\)_(?!\s)(.+?)(?<!\s)_", r"<i>\1</i>", text)

    # Strip common Markdown line prefixes.
    text = re.sub(r"(?m)^\s*#{1,6}\s*", "", text)
    text = re.sub(r"(?m)^\s*[-*â€¢]+\s+", "", text)

    # Remove code fences/backticks and any remaining emphasis markers.
    text = text.replace("```", "")
    text = text.replace("`", "")
    text = text.replace("**", "").replace("__", "").replace("*", "").replace("_", "")
    text = text.replace("#", "")

    # Normalise common HTML aliases generated by LLMs.
    text = re.sub(r"(?i)<\s*strong\s*>", "<b>", text)
    text = re.sub(r"(?i)<\s*/\s*strong\s*>", "</b>", text)
    text = re.sub(r"(?i)<\s*em\s*>", "<i>", text)
    text = re.sub(r"(?i)<\s*/\s*em\s*>", "</i>", text)

    # Preserve only allowed Telegram tags via placeholders.
    placeholders = {}

    def _protect_allowed_tag(match):
        key = f"__TG_TAG_{len(placeholders)}__"
        is_closing = bool(match.group(1))
        tag = match.group(2).lower()
        placeholders[key] = f"</{tag}>" if is_closing else f"<{tag}>"
        return key

    text = _ALLOWED_TAG_RE.sub(_protect_allowed_tag, text)

    # Remove any other tag-like structures.
    text = re.sub(r"<\s*/?\s*[A-Za-z][^>]*>", "", text)

    # Escape raw entities so symbols like '&' and comparison operators do not break HTML parsing.
    text = html.escape(text, quote=False)

    # Restore only allowed tags.
    for key, tag in placeholders.items():
        text = text.replace(key, tag)

    # Ensure the resulting HTML is balanced and parseable.
    text = _balance_allowed_tags(text)
    return text.strip()
